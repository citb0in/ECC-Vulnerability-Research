import ecdsa
from ecdsa import SECP256k1
from ecdsa.ellipticcurve import Point
from ecdsa.numbertheory import inverse_mod
import bitcoin


def point_add(point1, point2, curve):
    """Add two points on the given elliptic curve."""
    # Check if either point is the point at infinity
    if point1.x() is None or point1.y() is None:
        return point2
    if point2.x() is None or point2.y() is None:
        return point1

    # Handle the case where the points are the same
    if point1 == point2:
        return point_double(point1, curve)

    # Handle the case where the x-coordinates are the same
    if point1.x() == point2.x():
        # This represents the point at infinity
        return Point(curve, None, None)

    # Perform the point addition
    # m = (y2 - y1) / (x2 - x1)
    m = (point2.y() - point1.y()) * \
        inverse_mod(point2.x() - point1.x(), curve.p())
    # x3 = m^2 - x1 - x2
    x3 = (m * m - point1.x() - point2.x()) % curve.p()
    # y3 = m * (x1 - x3) - y1
    y3 = (m * (point1.x() - x3) - point1.y()) % curve.p()

    return Point(curve, x3, y3)


def point_double(point, curve):
    """Double a point on the given elliptic curve."""
    if point.y() == 0:
        return Point(curve, None, None)  # Point at infinity

    # m = (3 * x^2 + a) / (2 * y)
    m = ((3 * point.x() * point.x()) + curve.a()) * \
        inverse_mod(2 * point.y(), curve.p())
    # x3 = m^2 - 2 * x
    x3 = (m * m - 2 * point.x()) % curve.p()
    # y3 = m * (x - x3) - y
    y3 = (m * (point.x() - x3) - point.y()) % curve.p()

    return Point(curve, x3, y3)


def point_halving(point):
    """ Halving the provided point """
    return point * 57896044618658097711785492504343953926418782139537452191302581570759080747169


def point_subtract(point, other, curve):
    """Subtract one point from another on the given elliptic curve."""
    # Inverting the y-coordinate of 'other' point
    inverse_y = (-other.y() % curve.p())
    inverse_point = Point(curve, other.x(), inverse_y)

    # Adding point to the inverse of the other point
    return point + inverse_point


def get_coordinates_from_uncompressed_pubkey(pubkey_hex):
    """
    Extract coordinates from an uncompressed public key.

    Args:
    pubkey_hex (str): The hexadecimal representation of the uncompressed public key.

    Returns:
    tuple: The x and y coordinates as integers.
    """
    # Ensure the public key is uncompressed and starts with '04'
    if not pubkey_hex.startswith('04'):
        raise ValueError("The public key is not in uncompressed format")

    # Remove the '04' prefix
    key_hex = pubkey_hex[2:]

    # The length of the x and y coordinates should be equal
    coord_length = len(key_hex) // 2

    # Extract the x and y coordinates
    x_hex = key_hex[:coord_length]
    y_hex = key_hex[coord_length:]

    # Convert hex to integers
    x = int(x_hex, 16)
    y = int(y_hex, 16)

    return x, y


def get_first_point():
    pubkey = bitcoin.privkey_to_pubkey(1)
    return Point(SECP256k1.curve,
                 pubkey[0],
                 pubkey[1])


def get_point_exponent(point, scalar):
    """ NOT COMPLETE: Should return point exponent point^scalar """
    return point * scalar


def point_multiplication(point1, point2):
    """ NOT COMPLETE: Should return point multiplication point1 * point2 """
    return point1


def is_point_odd(point):
    """ (P * (P^m-2 % m)) % m will give modulo 2 for the point """
    CURVE_MAX = 115792089237316195423570985008687907852837564279074904382605163141518161494337

    scalar = CURVE_MAX - 2

    point_exponent = get_point_exponent(point, scalar)
    modulo_2_result = point_multiplication(point, point_exponent)

    if modulo_2_result == get_first_point():
        return True

    return False


def get_private_key_from_public_point(point):
    """ Extracts private key from a public key point, this method reverses Double and Add method by Subtract and Halve """

    NEXT = point
    BINARY_ORDER = ""
    G = ecdsa.SECP256k1.generator

    for i in range(0, 256):
        if NEXT == get_first_point():
            break

        PSUB = point_subtract(NEXT, G, SECP256k1.curve)
        SUBTRACT_AND_HALVE = point_halving(PSUB)
        JUST_HALVE = point_halving(NEXT)

        if is_point_odd(NEXT):
            BINARY_ORDER = "1" + BINARY_ORDER
            NEXT = SUBTRACT_AND_HALVE
        else:
            BINARY_ORDER = "0" + BINARY_ORDER
            NEXT = JUST_HALVE

    found_private_key = int(BINARY_ORDER, 2)
    return found_private_key


pubkey = get_coordinates_from_uncompressed_pubkey(
    "040000356cb2e0d0c0a0167693b14c338f548da20fea024a04449907140fa270ebff37ae70d00db8137b5c60d9563b743b090f162f7bf1b51650d20cd7022d695d")

P = Point(SECP256k1.curve,
          pubkey[0],
          pubkey[1])

print(get_private_key_from_public_point(P))
